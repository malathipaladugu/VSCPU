library ieee;
use ieee.std_logic_1164.all; use ieee.numeric_std.all;use ieee.std_logic_unsigned.ALL;
entity vscpu is2
generic (vscpu_add_width: integer:=8;vscpu_data_width:integer:=16;
pc_starts_at:std_logic_vector (7 downto 0) :="00000001");
port(clk,reset,start,write1: in std_logic;
addr: in std_logic_vector((vscpu_add_width)-1 downto 0);
data:in std_logic_vector((vscpu_data_width)-1 downto 0));
--status: out std_logic);
end vscpu;
architecture behav of vscpu is
constant memsize:integer:=(2**(vscpu_add_width)-1);
constant instr_add: std_logic_vector(7 downto 0):= "00000000";
constant instr_and:std_logic_vector(7 downto 0):="00000001";
constant instr_jmp:std_logic_vector(7 downto 0):="00000010";
constant instr_inc:std_logic_vector(7 downto 0):="00000011";
constant instr_store:std_logic_vector(7 downto 0):="00000100";
constant instr_sub:std_logic_vector(7 downto 0):="00000101";
constant instr_mul:std_logic_vector(7 downto 0):="00000110";
constant instr_load:std_logic_vector(7 downto 0):="00000111";
constant instr_decr:std_logic_vector(7 downto 0):="00001000";
constant st_fetch1: std_logic_vector(7 downto 0):="00000001";
constant st_fetch2: std_logic_vector(7 downto 0):="00000010";
constant st_fetch3: std_logic_vector(7 downto 0):="00000011";constant st_add1: std_logic_vector(7 downto 0):="00000100";
constant st_add2: std_logic_vector(7 downto 0):="00000101";
constant st_and1: std_logic_vector(7 downto 0):="00000110";
constant st_and2: std_logic_vector(7 downto 0):="00000111";
constant st_jmp1: std_logic_vector(7 downto 0):="00001000";
constant st_inc1: std_logic_vector(7 downto 0):="00001001";
constant st_store1: std_logic_vector(7 downto 0):="00001010";
constant st_halt: std_logic_vector(7 downto 0):="00111111";
constant st_sub1: std_logic_vector(7 downto 0):="00001011";
constant st_sub2: std_logic_vector(7 downto 0):="00001100";
constant st_mul1: std_logic_vector(7 downto 0):="00001110";
constant st_mul2: std_logic_vector(7 downto 0):="00001111";
constant st_load1:std_logic_vector(7 downto 0):="00010000";
constant st_decr1:std_logic_vector(7 downto 0):="00010001";
type t_mem is array (0 to memsize) of std_logic_vector((vscpu_data_width)-1 downto
0);
signal mem:t_mem;
signal read1,mem_write: std_logic; signal dbus: std_logic_vector((vscpu_data_width)-1
downto 0);
signal address,ar_ff,pc_ff,ar_ns,pc_ns: std_logic_vector((vscpu_add_width)-1 downto
0);
signal ac_ff,ac_ns: std_logic_vector(15 downto 0);
signal dr_ff,dr_ns:std_logic_vector((vscpu_data_width)-1 downto 0);
signal ir_ff,ir_ns,stvar_ff,stvar_ns:std_logic_vector(7 downto 0);
begin
process(clk,reset,ac_ns,pc_ns,ir_ns,dr_ns)
begin
if(rising_edge(clk)) then
if(reset='1') then
ar_ff<=(others=> '0');ac_ff<=(others=> '0');dr_ff<=(others=>
'0');ir_ff<=(others=> '0');pc_ff<=pc_starts_at;
else
ar_ff<=ar_ns;ac_ff<=ac_ns;dr_ff<=dr_ns;ir_ff<=ir_ns;pc_ff<=pc_ns;
end if;
end if;end process;
process(clk)
begin
if(rising_edge(clk)) then
if(reset='1') then
stvar_ff<=st_halt;
elsif(start='1') then
stvar_ff<=st_fetch1;
else stvar_ff<=stvar_ns;
end if;
end if;
end process;
process(stvar_ff,ir_ff)
begin
stvar_ns<= stvar_ff;
case(stvar_ff) is
when st_halt=> stvar_ns<= st_halt;
when st_fetch1=> stvar_ns<= st_fetch2;
when st_fetch2=> stvar_ns<= st_fetch3;
when st_fetch3 =>
case(ir_ff) is
when instr_add=> stvar_ns<=st_add1;
when instr_and=> stvar_ns<=st_and1;
when instr_jmp=> stvar_ns<=st_jmp1;
when instr_inc=> stvar_ns<=st_inc1;
when instr_store=> stvar_ns<=st_store1;
when instr_mul=> stvar_ns<=st_mul1;
when instr_sub=> stvar_ns<=st_sub1;
when instr_load=> stvar_ns<=st_load1;
when instr_decr=> stvar_ns<=st_decr1;
when others => null ;
end case;
when st_add1=> stvar_ns<=st_add2;
when st_and1=> stvar_ns<=st_and2;
when st_jmp1=> stvar_ns<=st_fetch1;
when st_inc1=> stvar_ns<=st_fetch1;
when st_store1=> stvar_ns<=st_fetch1;when st_add2=> stvar_ns<=st_fetch1;
when st_and2=> stvar_ns<=st_fetch1;
when st_sub1=> stvar_ns<=st_sub2;
when st_sub2=> stvar_ns<=st_fetch1;
when st_mul1=> stvar_ns<=st_mul2;
when st_mul2=> stvar_ns<=st_fetch1;
when st_load1=> stvar_ns<=st_fetch1;
when st_decr1=> stvar_ns<=st_fetch1;
when others => null ;
end case;
end process;
process(stvar_ff,ir_ff,ar_ff,pc_ff,dr_ff,ac_ff,dr_ns,dbus,mem_write)
begin
ar_ns<=ar_ff;ac_ns<=ac_ff;dr_ns<=dr_ff;ir_ns<=ir_ff;pc_ns<=pc_ff;
case(stvar_ff) is
when st_fetch1=> ar_ns<=pc_ff;
when st_fetch2=>
pc_ns<= std_logic_vector(unsigned(pc_ff)+1);dr_ns<= dbus;
ir_ns<= dr_ns((vscpu_data_width)-1 downto (vscpu_data_width)-8);
ar_ns<= dr_ns((vscpu_data_width)-9 downto 0);
when st_fetch3=>null;
when (st_add1) => dr_ns<=dbus;
when(st_add2) => ac_ns<= std_logic_vector(unsigned(ac_ff)+
unsigned(dr_ff));
when(st_and1) => dr_ns<=dbus;
when(st_and2) => ac_ns<= ac_ff and dr_ff;
when(st_jmp1) => pc_ns<= dr_ff((vscpu_data_width)-9 downto 0);
when(st_inc1) => ac_ns<=std_logic_vector(unsigned(ac_ff)+1);
when(st_sub1) => dr_ns<= dbus;
when(st_sub2) =>
ac_ns<=std_logic_vector(unsigned(ac_ff)-unsigned(dr_ff));
when(st_mul1) => dr_ns<= dbus;
when(st_mul2) => ac_ns<=std_logic_vector(unsigned(ac_ff(7
downto 0))*unsigned(dr_ff(7 downto 0)));
when(st_load1) => ac_ns<=dbus ;
when(st_decr1) => ac_ns<=std_logic_vector(unsigned(ac_ff)-1);when others=> null;
end case;
end process;
--Memory block--
address <= addr when (stvar_ff = st_halt ) else ar_ff ;
process(clk,reset,read1,write1)
begin
if(rising_edge(clk)) then
if(reset='1') then
mem<=(others=>(others=>'0'));
elsif ((write1 and (not read1))='1') then
mem(to_integer(unsigned(address)))<=data;
elsif (mem_write='1' and read1='0') then
mem(to_integer(unsigned(address)))<=dbus;
end if;
end if;
end process;
dbus<= mem(to_integer(unsigned(address))) when ((read1 and (not write1))='1')
else ac_ff when ((mem_write and (not read1))='1')
else (others=>'Z');
process(clk,reset,start)
begin
if(rising_edge(clk)) then
if(reset='1') then
stvar_ff <= st_halt;
elsif(start='1') then
stvar_ff <= st_fetch1;
else stvar_ff <= stvar_ns ;
end if;
end if;
end process;
--------------------------
---control path---
process(stvar_ff,pc_ff,ac_ff,dr_ff,ir_ff,ar_ff)
beginif ( (stvar_ff= st_fetch2) or (stvar_ff=st_add1) or (stvar_ff=st_and1) or (stvar_ff=st_sub1)
or(stvar_ff=st_mul1) or (stvar_ff=st_load1) ) then
read1 <= '1' ;mem_write<='0';
elsif(stvar_ff=st_store1) then mem_write<='1'; read1<='0';
else read1 <= '0' ;mem_write<='0';
end if;
end process;
end behav;
Testbench:
library ieee ; use ieee.std_logic_1164.all ;
entity vscputb is end entity ;
architecture stim of vscputb is
constant INSTR_add : std_logic_vector( 7 downto 0 ) := "00000000" ;
constant INSTR_and : std_logic_vector( 7 downto 0 ) := "00000001" ;
constant INSTR_jmp : std_logic_vector( 7 downto 0 ) := "00000010" ;
constant INSTR_inc : std_logic_vector( 7 downto 0 ) := "00000011" ;
constant INSTR_store : std_logic_vector( 7 downto 0 ) := "00000100" ;
constant INSTR_sub : std_logic_vector( 7 downto 0 ) := "00000101" ;
constant INSTR_mul : std_logic_vector( 7 downto 0 ) := "00000110" ;
constant INSTR_load : std_logic_vector( 7 downto 0 ) := "00000111" ;
constant INSTR_decr : std_logic_vector( 7 downto 0 ) := "00001000" ;
constant A_WIDTH : integer := 8 ;
constant D_WIDTH : integer := 16 ;
signal clk , reset , start , write_en : std_logic:='0' ;
signal addr : std_logic_vector( A_WIDTH-1 downto 0 ) ;
signal data : std_logic_vector ( D_WIDTH-1 downto 0 ) ;
procedure do_synch_active_high_half_pulse (
signal formal_p_clk : in std_logic ;
signal formal_p_sig : out std_logic
) isbegin
wait until formal_p_clk='0' ; formal_p_sig <= '1' ;
wait until formal_p_clk='1' ; formal_p_sig <= '0' ;
end procedure ;
procedure do_program (
signal formal_p_clk : in std_logic ;
signal formal_p_write_en : out std_logic ;
signal formal_p_addr_out , formal_p_data_out : out std_logic_vector ;
formal_p_ADDRESS_in , formal_p_DATA_in : in std_logic_vector
) is
begin
wait until formal_p_clk='0' ; formal_p_write_en <= '1' ;
formal_p_addr_out <= formal_p_ADDRESS_in ;
formal_p_data_out <= formal_p_DATA_in ;
wait until formal_p_clk='1' ; formal_p_write_en <='0' ;
end procedure ;
begin
dut_vscpu : entity work.vscpu( behav )
port map ( clk => clk , reset => reset , start => start ,
write1 => write_en , addr => addr , data => data ) ;
process begin
clk <= '0' ;
for i in 0 to 99 loop
wait for 1 ns ; clk <= '1' ; wait for 1 ns ; clk <= '0';
end loop ;
wait;
end process ;
process begin
reset <= '0' ; start <= '0' ; write_en <= '0' ;
addr <= "00000000" ; data <= "0000000000000000" ;
do_synch_active_high_half_pulse ( clk, reset ) ; -- acc=0
do_program ( clk, write_en, addr, data, "00000001" , INSTR_load & "00" & "010000" ) ;
do_program ( clk, write_en, addr, data, "00000010" , INSTR_add & "00" & "010001" ) ;
do_program ( clk, write_en, addr, data, "00000011" , INSTR_store & "00" & "010010" ) ;do_program ( clk, write_en, addr, data, "00000100" , INSTR_and & "00" & "010011" ) ;
do_program ( clk, write_en, addr, data, "00000101" , INSTR_inc & "00" & "010100" ) ;
do_program ( clk, write_en, addr, data, "00000110" , INSTR_sub & "00" & "010110" ) ;
do_program ( clk, write_en, addr, data, "00000111" , INSTR_mul & "00" & "010111" ) ;
do_program ( clk, write_en, addr, data, "00001000" , INSTR_decr & "00" & "011000" ) ;
do_program ( clk, write_en, addr, data, "00001001" , INSTR_jmp & "00" & "010101" ) ;
do_program ( clk, write_en, addr, data, "00010000" , X"0016" ) ; -- mem[ 16 ]
do_program ( clk, write_en, addr, data, "00010001" , X"0039" ) ; -- mem[ 17 ]
do_program ( clk, write_en, addr, data, "00010011" , X"0002" ) ; -- mem[ 19 ]
do_program ( clk, write_en, addr, data, "00010110" , X"0001" ) ; -- mem[ 22 ]
do_program ( clk, write_en, addr, data, "00010111" , X"0016" ) ; -- mem[ 23 ]
do_synch_active_high_half_pulse ( clk, start ) ;
wait ;
end process ;
end architecture ;
